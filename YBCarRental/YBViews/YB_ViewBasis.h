#ifndef YB_ViewBasis_H
#define YB_ViewBasis_H

#include <iostream>
#include <map>
#include <vector>
#include <typeinfo>
#include "YB_ViewMessage.h"
#include "YB_DataBasis.h"
#include <functional>
#include "YB_DataSource_Interface.h"
//#include "YB_ViewItemFactory.h"
//#include "YB_ViewItemBasis.h"				// Forward declaration - some c++ specific trap

using namespace std;
using namespace YBPersistence;

namespace YBConsoleViews
{
	class YB_ViewItemBasis;					// Forward declaration - some c++ specific trap
	class YB_ViewItemFactory;
	class YB_Window;

	class YB_ViewBasis : public YBPersistence::YB_DataBasis
	{
	public:
		YB_ViewBasis();
		YB_ViewBasis(int* width, int* height);
		~YB_ViewBasis();
		#pragma region Copy assignment operator
		//=====================================================================================================================
		//Suggestion given by chatGPT to solve C2280 and deleted function error:
		// it's possible that the error is related to the copy assignment operator of your YB_User class. If the YB_User 
		// class contains non-trivial member variables (like pointers or dynamically allocated resources), the default 
		// copy assignment operator generated by the compiler might not handle them correctly.
		// To resolve this, you should define a copy assignment operator for your YB_User class that performs a deep copy
		// of its members.
		YB_ViewBasis& operator=(const YB_ViewBasis& other) {
			if (this != &other) {
				Title				= other.Title;
				ViewType			= other.ViewType;
				w					= other.w;
				h					= other.h;
				Background			= other.Background;
				Source				= other.Source;
				GotoView			= other.GotoView;
				ConfirmView			= other.ConfirmView;
				subItemsList		= other.subItemsList;

				dataSource			= other.dataSource;
				itemFactoryPtr		= other.itemFactoryPtr;
				fromViewPtr			= other.fromViewPtr;
				windowPtr			= other.windowPtr;

				viewArray			= other.viewArray;
				isUpdatedFlag		= other.isUpdatedFlag;
				isInitedFlag		= other.isInitedFlag;
				currentItemIndex	= other.currentItemIndex;


				// Deep copy of other resources, if any
				// For example, if 'myfile' is a pointer, you might need to handle it here

				// Call parent class copy assignment operator
				YB_DataBasis::operator=(other);
			}
			return *this;
		}
		//Also see to the explanation:
		// https://stackoverflow.com/questions/31264984/c-compiler-error-c2280-attempting-to-reference-a-deleted-function-in-visual
		//YB_ViewBasis& operator=(const YB_ViewBasis&) = default;		//this passed syntax check but doesn't solve the C2280
		//
		//The best solution will be try using pointers as much as possible instead of copying value, e.g.:
		//change the dataSet to map<int, TData*> in the persistor class;
		//However I will not go through this direction for simplicity consideration.
		//=====================================================================================================================
		#pragma endregion

		string							ViewType		= "";
		string							Title			= "";
		int								w = 200, h = 32;
		char							Background		= '.';
		string							Source			="";
		string							GotoView		="";
		string							ConfirmView		= "";

		//void AddViewItem(YB_ViewItemBasis item);
		//void AddViewItems(vector<YB_ViewItemBasis> items);

		virtual string*					Serialize()														override;
		virtual void					Serialize(std::stringstream& strStream)							override;
		virtual void					Deserialize(string line);
		virtual void					Deserialize(string line, const char* separator)					override;
		//void Serialize(ofstream* output) override;

		virtual void					Init();															
		virtual	void					Bind();	
		virtual void					BindList();														//datasource VM -> view: Bind values to viewItems from dataSource.
		virtual void					OnKey(int* keycode);
		virtual void					ReverseBind();													//view -> datasource VM: Reverse binding to VM (and upate/save)
		virtual void					Submit();
		virtual vector<char*>			Render();
		virtual void					Exit();
		virtual void					OnChildReturn	(YB_ViewMessageBasis*		Message, 
														YB_ViewItemBasis*		fromItemPtr);			//Entry point for internal items
		virtual void					OnConfirmReturn (YB_ViewMessageBasis*		message, 
														YB_ViewBasis*			fromViewPtr);			//Entry point between views
		void							Init_Background(char background);
		void							Fill_Background(char background);
		void							Clear_Background();
		void							PopPrompt(const char* promptPtr, const char* gotoLink);
		void							SetPrompt(YB_ViewItemBasis* promptPtr);

		bool							isInitedFlag					= false;						//indicator whether initiation completed
		bool							isBindedFlag					= false;						//indicator whether viewItems content has been set
		bool							isUpdatedFlag					= true;							//indicator for dirt-Rendering
		bool							isKeepStatusFlag				= false;						//indicator for keep-status after jumpback to another view

		//std::function<void()>			ViewReturnCallback;												//The callback scheme is not used in this project
		YB_ViewItemFactory*				itemFactoryPtr					= {};							//this could be used for runtime item generation
		YB_ViewBasis*					fromViewPtr;													//the previous view, so as to carry datasource forward
		YB_Window*						windowPtr;
		YB_DataSource_Interface*		dataSource;														//the ViewModel served as data source
		vector<YB_ViewItemBasis*>		subItemsList;
	protected:
		vector<YB_ViewItemBasis*>		focusableItems;													//Items affected by Tab key
		vector<YB_ViewItemBasis*>		bindableItems;													//Items affected by binding behaviour
		int								currentItemIndex				= -1;

	private:
		vector<char*>					viewArray;
		YB_ViewItemBasis*				promptBoxItemPtr;												//special treatment of prompt without support of z-depth
	};
}
#endif //YB_ViewBasis_H
